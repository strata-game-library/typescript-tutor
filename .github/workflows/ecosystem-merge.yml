# Ecosystem Merge - Merge Queue Consumer
# Reads tracking issue state and executes merge decisions
#
# Responsibilities:
# - Read verdict from tracking issue (KV store)
# - Check CI status
# - Auto-approve eligible PRs
# - Auto-rebase when needed
# - Execute merge
#
# Coordination: Triggered by CI completion or tracking issue state changes

name: Ecosystem Merge

on:
  # CI completion events
  check_suite:
    types: [completed]
  check_run:
    types: [completed]
  # Tracking issue state changes
  issues:
    types: [labeled]
  # PR state changes
  pull_request:
    types: [labeled, unlabeled]
  # Manual merge request
  issue_comment:
    types: [created]

permissions:
  contents: write
  pull-requests: write
  issues: write
  checks: read

concurrency:
  group: merge-${{ github.event.pull_request.number || github.event.issue.number || github.run_id }}
  cancel-in-progress: true

jobs:
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  # MERGE ASSESSMENT: Read KV store, check CI, decide
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  assess:
    name: Merge Assessment
    if: |
      (github.event_name == 'check_suite' && 
       github.event.check_suite.conclusion == 'success' &&
       github.event.check_suite.pull_requests[0] != null) ||
      (github.event_name == 'check_run' &&
       github.event.check_run.conclusion == 'success' &&
       github.event.check_run.pull_requests[0] != null) ||
      (github.event_name == 'issues' &&
       github.event.action == 'labeled' &&
       github.event.label.name == 'queue-ready') ||
      (github.event_name == 'pull_request') ||
      (github.event_name == 'issue_comment' &&
       contains(github.event.comment.body, '@cascade merge'))
    runs-on: ubuntu-latest
    outputs:
      can_merge: ${{ steps.assess.outputs.can_merge }}
      pr_number: ${{ steps.assess.outputs.pr_number }}
    steps:
      - name: Assess Merge Eligibility
        id: assess
        env:
          GH_TOKEN: ${{ secrets.CI_GITHUB_TOKEN }}
          ISSUE_TITLE: ${{ github.event.issue.title }}
        run: |
          # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          # RESOLVE PR NUMBER
          # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          case "${{ github.event_name }}" in
            check_suite)
              PR_NUM=$(echo '${{ toJson(github.event.check_suite.pull_requests) }}' | jq -r '.[0].number // empty')
              ;;
            check_run)
              PR_NUM=$(echo '${{ toJson(github.event.check_run.pull_requests) }}' | jq -r '.[0].number // empty')
              ;;
            pull_request)
              PR_NUM="${{ github.event.pull_request.number }}"
              ;;
            issue_comment)
              if [ -n "${{ github.event.issue.pull_request }}" ]; then
                PR_NUM="${{ github.event.issue.number }}"
              else
                # Comment on tracking issue - extract PR number from title (via env var for security)
                PR_NUM=$(echo "$ISSUE_TITLE" | grep -oE 'pr-([0-9]+)' | grep -oE '[0-9]+' || echo "")
              fi
              ;;
            issues)
              # Tracking issue labeled - extract PR number from title (via env var for security)
              PR_NUM=$(echo "$ISSUE_TITLE" | grep -oE 'pr-([0-9]+)' | grep -oE '[0-9]+' || echo "")
              ;;
            *)
              PR_NUM=""
              ;;
          esac
          
          [ -z "$PR_NUM" ] && echo "No PR number" && exit 0
          echo "pr_number=$PR_NUM" >> $GITHUB_OUTPUT
          
          echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
          echo "‚ïë  ‚öñÔ∏è MERGE ASSESSMENT: PR #$PR_NUM                          ‚ïë"
          echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
          
          # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          # GET PR STATE
          # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          PR_DATA=$(gh pr view $PR_NUM --repo "${{ github.repository }}" --json isDraft,mergeable,reviewDecision,title,labels,mergeStateStatus 2>/dev/null || echo "{}")
          
          IS_DRAFT=$(echo "$PR_DATA" | jq -r '.isDraft // false')
          MERGEABLE=$(echo "$PR_DATA" | jq -r '.mergeable // "UNKNOWN"')
          MERGE_STATE=$(echo "$PR_DATA" | jq -r '.mergeStateStatus // "UNKNOWN"')
          REVIEW=$(echo "$PR_DATA" | jq -r '.reviewDecision // "REVIEW_REQUIRED"')
          TITLE=$(echo "$PR_DATA" | jq -r '.title // "Unknown"')
          # shellcheck disable=SC2034
          HAS_AUTO=$(echo "$PR_DATA" | jq '[.labels[]?.name // empty] | map(select(. == "auto-merge")) | length')
          
          echo ""
          echo "üìã PR: $TITLE"
          echo "   Draft: $IS_DRAFT | Mergeable: $MERGEABLE | State: $MERGE_STATE"
          
          [ "$IS_DRAFT" = "true" ] && echo "‚è∏Ô∏è Draft - skipping" && exit 0
          
          # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          # READ TRACKING ISSUE (KV Store)
          # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          echo ""
          echo "üìñ Reading tracking issue..."
          
          TRACKING=$(gh issue list --repo "${{ github.repository }}" --label "synthesis" --search "synthesis-pr-$PR_NUM in:title" --json number,labels --jq '.[0]' 2>/dev/null || echo "{}")
          TRACKING_NUM=$(echo "$TRACKING" | jq -r '.number // empty')
          
          VERDICT="UNKNOWN"
          if [ -n "$TRACKING_NUM" ]; then
            # Check labels for verdict
            if echo "$TRACKING" | jq -e '.labels[] | select(.name == "queue-blocked")' > /dev/null 2>&1; then
              VERDICT="BLOCKED"
            elif echo "$TRACKING" | jq -e '.labels[] | select(.name == "queue-ready")' > /dev/null 2>&1; then
              VERDICT="READY"
            elif echo "$TRACKING" | jq -e '.labels[] | select(.name == "queue-review")' > /dev/null 2>&1; then
              VERDICT="REVIEW"
            fi
            echo "   Tracking issue: #$TRACKING_NUM ‚Üí $VERDICT"
          else
            echo "   No tracking issue found"
            VERDICT="CLEAR"  # No tracking = no known blockers
          fi
          
          # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          # CHECK CI STATUS
          # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          echo ""
          echo "üî¨ Checking CI..."
          
          FAILED=$(gh pr checks $PR_NUM --json conclusion --jq '[.[] | select(.conclusion == "FAILURE" or .conclusion == "TIMED_OUT")] | length' 2>/dev/null || echo "0")
          PENDING=$(gh pr checks $PR_NUM --json state --jq '[.[] | select(.state == "PENDING" or .state == "QUEUED")] | length' 2>/dev/null || echo "0")
          
          echo "   Failed: $FAILED | Pending: $PENDING"
          
          CI_READY=false
          [ "$FAILED" -eq 0 ] && [ "$PENDING" -eq 0 ] && CI_READY=true
          
          # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          # DECISION
          # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          echo ""
          echo "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê"
          echo "‚îÇ                   DECISION MATRIX                       ‚îÇ"
          echo "‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§"
          printf "‚îÇ %-21s ‚îÇ %-31s ‚îÇ\n" "CI Ready" "$([ "$CI_READY" = true ] && echo '‚úÖ' || echo '‚ùå')"
          printf "‚îÇ %-21s ‚îÇ %-31s ‚îÇ\n" "Mergeable" "$([ "$MERGEABLE" = 'MERGEABLE' ] && echo '‚úÖ' || echo "‚ùå $MERGEABLE")"
          printf "‚îÇ %-21s ‚îÇ %-31s ‚îÇ\n" "Verdict" "$VERDICT"
          printf "‚îÇ %-21s ‚îÇ %-31s ‚îÇ\n" "Review" "$REVIEW"
          echo "‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò"
          
          CAN_MERGE=false
          REASON=""
          
          if [ "$CI_READY" = true ] && [ "$MERGEABLE" = "MERGEABLE" ]; then
            case "$VERDICT" in
              READY|CLEAR)
                CAN_MERGE=true
                REASON="CI ‚úÖ + Mergeable ‚úÖ + Queue clear"
                ;;
              REVIEW)
                CAN_MERGE=true
                REASON="CI ‚úÖ + Mergeable ‚úÖ + Non-critical feedback"
                ;;
              BLOCKED)
                REASON="Blocked by critical issues in tracking issue"
                ;;
              *)
                CAN_MERGE=true
                REASON="CI ‚úÖ + Mergeable ‚úÖ + No blockers"
                ;;
            esac
          elif [ "$CI_READY" = false ]; then
            REASON="CI not ready ($FAILED failed, $PENDING pending)"
          elif [ "$MERGEABLE" != "MERGEABLE" ]; then
            REASON="PR not mergeable ($MERGEABLE)"
          fi
          
          echo ""
          echo "can_merge=$CAN_MERGE" >> $GITHUB_OUTPUT
          
          if [ "$CAN_MERGE" = true ]; then
            echo "‚úÖ ELIGIBLE: $REASON"
          else
            echo "‚è∏Ô∏è NOT ELIGIBLE: $REASON"
          fi

  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  # APPROVE: Auto-approve eligible PRs
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  approve:
    name: Auto-Approve
    needs: assess
    if: needs.assess.outputs.can_merge == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Approve PR
        env:
          GH_TOKEN: ${{ secrets.CI_GITHUB_TOKEN }}
          PR_NUM: ${{ needs.assess.outputs.pr_number }}
        run: |
          # PR_NUM passed via env to prevent code injection
          
          # Check current review state
          REVIEW=$(gh pr view $PR_NUM --repo "${{ github.repository }}" --json reviewDecision --jq '.reviewDecision' 2>/dev/null || echo "")
          
          if [ "$REVIEW" = "APPROVED" ]; then
            echo "‚úÖ Already approved"
            exit 0
          fi
          
          echo "üìù Approving PR #$PR_NUM..."
          
          gh pr review $PR_NUM --approve --body "‚úÖ **Auto-approved by Ecosystem Merge**

          | Check | Status |
          |-------|--------|
          | CI | ‚úÖ Passed |
          | Mergeable | ‚úÖ Ready |
          | Queue | ‚úÖ Clear |

          Proceeding with merge." 2>/dev/null || echo "Could not approve (may need different token)"
          
          # Add auto-merge label
          gh label create "auto-merge" --repo "${{ github.repository }}" --color "0E8A16" 2>/dev/null || true
          gh pr edit $PR_NUM --repo "${{ github.repository }}" --add-label "auto-merge" 2>/dev/null || true

  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  # REBASE: Auto-rebase if behind
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  rebase:
    name: Auto-Rebase
    needs: assess
    if: needs.assess.outputs.can_merge == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Check and Rebase
        env:
          GH_TOKEN: ${{ secrets.CI_GITHUB_TOKEN }}
          PR_NUM: ${{ needs.assess.outputs.pr_number }}
        run: |
          # PR_NUM passed via env to prevent code injection
          
          # Check merge state
          MERGE_STATE=$(gh pr view $PR_NUM --repo "${{ github.repository }}" --json mergeStateStatus --jq '.mergeStateStatus' 2>/dev/null || echo "")
          
          if [ "$MERGE_STATE" != "BEHIND" ]; then
            echo "‚úÖ PR is up to date"
            exit 0
          fi
          
          echo "üîÑ PR is behind, attempting rebase..."
          
          # Try GitHub's update branch API
          gh api -X PUT repos/${{ github.repository }}/pulls/$PR_NUM/update-branch \
            -f update_method=rebase 2>/dev/null && echo "‚úÖ Rebased via API" && exit 0
          
          echo "‚ö†Ô∏è API rebase failed, manual rebase may be needed"

  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  # MERGE: Execute the merge
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  merge:
    name: Execute Merge
    needs: [assess, approve, rebase]
    if: |
      always() &&
      needs.assess.outputs.can_merge == 'true' &&
      (needs.approve.result == 'success' || needs.approve.result == 'skipped') &&
      (needs.rebase.result == 'success' || needs.rebase.result == 'skipped')
    runs-on: ubuntu-latest
    steps:
      - name: Merge PR
        env:
          GH_TOKEN: ${{ secrets.CI_GITHUB_TOKEN }}
          PR_NUM: ${{ needs.assess.outputs.pr_number }}
        run: |
          # PR_NUM passed via env to prevent code injection
          
          echo "üöÄ Attempting to merge PR #$PR_NUM..."
          
          # Final check
          PR_DATA=$(gh pr view $PR_NUM --repo "${{ github.repository }}" --json mergeable,mergeStateStatus,isDraft)
          MERGEABLE=$(echo "$PR_DATA" | jq -r '.mergeable')
          STATE=$(echo "$PR_DATA" | jq -r '.mergeStateStatus')
          DRAFT=$(echo "$PR_DATA" | jq -r '.isDraft')
          
          if [ "$DRAFT" = "true" ]; then
            echo "‚è∏Ô∏è PR is draft - cannot merge"
            exit 0
          fi
          
          if [ "$MERGEABLE" != "MERGEABLE" ]; then
            echo "‚è∏Ô∏è PR not mergeable: $MERGEABLE"
            exit 0
          fi
          
          if [ "$STATE" = "BEHIND" ]; then
            echo "‚è∏Ô∏è PR is behind - waiting for rebase"
            exit 0
          fi
          
          # Merge with squash
          if gh pr merge $PR_NUM --squash --delete-branch 2>/dev/null; then
            echo "‚úÖ PR #$PR_NUM merged successfully!"
            
            # Close tracking issue
            TRACKING=$(gh issue list --repo "${{ github.repository }}" --label "synthesis" --search "synthesis-pr-$PR_NUM in:title" --json number --jq '.[0].number // empty' 2>/dev/null)
            if [ -n "$TRACKING" ]; then
              gh issue close $TRACKING --repo "${{ github.repository }}" --comment "‚úÖ PR #$PR_NUM merged." 2>/dev/null || true
            fi
          else
            echo "‚ö†Ô∏è Merge failed - may need manual intervention"
          fi
