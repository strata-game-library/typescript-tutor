name: Ollama PR Orchestrator

# Autonomous PR lifecycle management:
# - Automatic code review on PR open
# - Monitors ALL AI agent feedback (Gemini, Copilot, Q, CodeRabbit, etc.)
# - Analyzes, triages, and resolves AI feedback automatically
# - Applies fixes and commits them
# - Resolves comment threads
# - Removes draft status when ready
# - Auto-merges when all feedback satisfied and CI green

on:
  pull_request:
    types: [opened, synchronize, ready_for_review]
  pull_request_review:
    types: [submitted]
  pull_request_review_comment:
    types: [created]
  issue_comment:
    types: [created]
  check_suite:
    types: [completed]

permissions:
  contents: write
  pull-requests: write
  issues: write
  checks: read
  security-events: write  # For Copilot autofix API access

env:
  OLLAMA_HOST: ${{ vars.OLLAMA_HOST || 'https://ollama.com' }}
  OLLAMA_MODEL: ${{ vars.OLLAMA_MODEL || 'glm-4.6:cloud' }}
  # Known AI agent bot names - includes github-actions[bot] for self-feedback loop
  AI_AGENTS: "gemini-code-assist[bot],copilot[bot],amazon-q-developer[bot],coderabbitai[bot],cursor[bot],github-advanced-security[bot],dependabot[bot]"

jobs:
  # ============================================
  # Initial Review - On PR open/sync
  # ============================================
  initial-review:
    name: Initial Code Review
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    outputs:
      pr_number: ${{ github.event.pull_request.number }}
      recommendation: ${{ steps.review.outputs.recommendation }}
    
    steps:
      - name: Check required secrets
        env:
          OLLAMA_API_KEY: ${{ secrets.OLLAMA_API_KEY }}
        run: |
          if [[ -z "$OLLAMA_API_KEY" ]]; then
            echo "::error::OLLAMA_API_KEY secret is not configured"
            exit 1
          fi

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha }}
          # Use CI_GITHUB_TOKEN to allow commits to trigger workflows
          token: ${{ secrets.CI_GITHUB_TOKEN || secrets.GITHUB_TOKEN }}

      - name: Get PR diff
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh pr diff ${{ github.event.pull_request.number }} --color=never > /tmp/pr_diff.txt

      - name: Generate structured review
        id: review
        env:
          OLLAMA_API_KEY: ${{ secrets.OLLAMA_API_KEY }}
        run: |
          # Schema for structured output
          cat > /tmp/schema.json << 'EOF'
          {
            "type": "object",
            "properties": {
              "summary": { "type": "string" },
              "issues": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "file": { "type": "string" },
                    "line": { "type": "integer" },
                    "severity": { "type": "string", "enum": ["low", "medium", "high", "critical"] },
                    "description": { "type": "string" },
                    "fix": { "type": "string" }
                  },
                  "required": ["file", "severity", "description"]
                }
              },
              "fixes": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "file": { "type": "string" },
                    "old_content": { "type": "string" },
                    "new_content": { "type": "string" },
                    "description": { "type": "string" }
                  },
                  "required": ["file", "old_content", "new_content", "description"]
                }
              },
              "score": { "type": "integer", "minimum": 1, "maximum": 10 },
              "recommendation": { "type": "string", "enum": ["approve", "request_changes", "comment"] },
              "auto_apply": { "type": "boolean" }
            },
            "required": ["summary", "issues", "fixes", "score", "recommendation", "auto_apply"]
          }
          EOF
          
          cat > /tmp/prompt.txt << 'EOF'
          You are an expert code reviewer. Analyze this diff and provide:
          1. A concise summary
          2. List of issues by severity (critical, high, medium, low)
          3. Concrete fixes with exact old_content and new_content for search/replace
          4. A score from 1-10
          5. recommendation: approve (score >= 8, no critical/high), request_changes (critical/high issues), comment (otherwise)
          6. auto_apply: true only if fixes are safe refactoring with no behavior change
          
          Be thorough but practical. Focus on real issues, not style nitpicks.
          
          DIFF:
          EOF
          
          head -c 100000 /tmp/pr_diff.txt >> /tmp/prompt.txt
          
          jq -n \
            --arg model "$OLLAMA_MODEL" \
            --rawfile prompt /tmp/prompt.txt \
            --slurpfile schema /tmp/schema.json \
            '{
              model: $model,
              messages: [
                { role: "system", content: "Expert code reviewer. Respond with valid JSON only." },
                { role: "user", content: $prompt }
              ],
              format: $schema[0],
              options: { temperature: 0.1, num_ctx: 131072, num_predict: 8192 },
              stream: false
            }' > /tmp/payload.json
          
          if curl -sf --max-time 300 \
            -H "Authorization: Bearer $OLLAMA_API_KEY" \
            -H "Content-Type: application/json" \
            -d @/tmp/payload.json \
            "$OLLAMA_HOST/api/chat" > /tmp/response.json; then
            jq -r '.message.content // empty' /tmp/response.json > /tmp/review.json
          else
            echo '{"summary":"API error","issues":[],"fixes":[],"score":5,"recommendation":"comment","auto_apply":false}' > /tmp/review.json
          fi
          
          # Validate
          if ! jq empty /tmp/review.json 2>/dev/null; then
            echo '{"summary":"Parse error","issues":[],"fixes":[],"score":5,"recommendation":"comment","auto_apply":false}' > /tmp/review.json
          fi
          
          echo "recommendation=$(jq -r '.recommendation' /tmp/review.json)" >> $GITHUB_OUTPUT
          echo "auto_apply=$(jq -r '.auto_apply' /tmp/review.json)" >> $GITHUB_OUTPUT

      - name: Apply safe fixes
        if: steps.review.outputs.auto_apply == 'true'
        run: |
          jq -c '.fixes[]' /tmp/review.json | while read -r fix; do
            FILE=$(echo "$fix" | jq -r '.file')
            OLD=$(echo "$fix" | jq -r '.old_content')
            NEW=$(echo "$fix" | jq -r '.new_content')
            
            # Security check
            if [[ "$FILE" =~ \.\./|^/ ]]; then
              echo "Skipping unsafe path: $FILE"
              continue
            fi
            
            # Validate OLD is not empty (prevents file corruption)
            if [[ -z "$OLD" ]]; then
              echo "‚ö†Ô∏è Skipping fix with empty old_content"
              continue
            fi
            
            if [[ -f "$FILE" ]] && grep -qF "$OLD" "$FILE"; then
              # Use perl with environment variables to handle slashes in content
              OLD="$OLD" NEW="$NEW" perl -i -p0e 's/\Q$ENV{OLD}\E/$ENV{NEW}/s' "$FILE" && echo "‚úÖ Fixed: $FILE"
            fi
          done

      - name: Commit fixes
        if: steps.review.outputs.auto_apply == 'true'
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "fix: auto-apply safe improvements (Ollama)"
          branch: ${{ github.head_ref }}

      - name: Submit review
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          SUMMARY=$(jq -r '.summary' /tmp/review.json)
          SCORE=$(jq -r '.score' /tmp/review.json)
          REC=$(jq -r '.recommendation' /tmp/review.json)
          ISSUES=$(jq '.issues | length' /tmp/review.json)
          
          BODY="## ü§ñ Ollama Code Review

          **Summary:** $SUMMARY

          | Score | Issues | Recommendation |
          |-------|--------|----------------|
          | $SCORE/10 | $ISSUES | $REC |

          <details>
          <summary>Details</summary>

          \`\`\`json
          $(cat /tmp/review.json)
          \`\`\`
          </details>"
          
          EVENT="COMMENT"
          [[ "$REC" == "approve" ]] && EVENT="APPROVE"
          [[ "$REC" == "request_changes" ]] && EVENT="REQUEST_CHANGES"
          
          gh api repos/${{ github.repository }}/pulls/${{ github.event.pull_request.number }}/reviews \
            -f body="$BODY" -f event="$EVENT" || gh pr comment ${{ github.event.pull_request.number }} --body "$BODY"

      - name: Upload review artifact
        uses: actions/upload-artifact@v4
        with:
          name: ollama-review
          path: /tmp/review.json
          retention-days: 1

  # ============================================
  # Self-Resolve - Process our own review (chains after initial-review)
  # GitHub doesn't trigger events for GITHUB_TOKEN actions, so we chain directly
  # ============================================
  self-resolve:
    name: Self-Resolve Issues
    needs: initial-review
    if: needs.initial-review.outputs.recommendation == 'request_changes'
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha }}
          # Use CI_GITHUB_TOKEN to allow commits to trigger workflows
          token: ${{ secrets.CI_GITHUB_TOKEN || secrets.GITHUB_TOKEN }}

      - name: Checkout PR branch
        env:
          HEAD_REF: ${{ github.head_ref }}
        run: git checkout "$HEAD_REF"

      - name: Download review artifact
        uses: actions/download-artifact@v4
        with:
          name: ollama-review
          path: /tmp

      - name: Analyze and resolve our own issues
        id: resolve
        env:
          OLLAMA_API_KEY: ${{ secrets.OLLAMA_API_KEY }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Read our own review
          ISSUES=$(jq '.issues' /tmp/review.json)
          ISSUE_COUNT=$(echo "$ISSUES" | jq 'length')
          
          if [[ "$ISSUE_COUNT" == "0" ]]; then
            echo "No issues to resolve"
            echo "resolved=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "üìã Found $ISSUE_COUNT issues to analyze"
          
          # Get the diff for context
          gh pr diff ${{ github.event.pull_request.number }} --color=never > /tmp/diff.txt 2>/dev/null || true
          
          cat > /tmp/prompt.txt << 'EOF'
          You are resolving issues from your own code review. For each issue, determine:
          
          1. Is this a REAL issue that needs fixing? Or is it an INTENTIONAL change that should be acknowledged?
          2. If it needs fixing, provide exact old_content and new_content for search/replace
          3. If it's intentional (e.g., "file deleted" when deletion was the goal), mark as acknowledged
          
          Categories:
          - fix: Real issue, provide fix
          - acknowledge: Intentional change, no fix needed
          - dismiss: False positive or not actionable
          
          Respond with JSON:
          {
            "resolutions": [
              {
                "issue_description": "original issue",
                "category": "fix|acknowledge|dismiss", 
                "reason": "why this resolution",
                "file": "path if fix",
                "old_content": "if fix",
                "new_content": "if fix"
              }
            ],
            "summary": "overall summary",
            "all_resolved": true/false
          }
          
          ISSUES TO RESOLVE:
          EOF
          
          echo "$ISSUES" >> /tmp/prompt.txt
          echo -e "\n\nCURRENT DIFF:\n" >> /tmp/prompt.txt
          head -c 50000 /tmp/diff.txt >> /tmp/prompt.txt
          
          jq -n \
            --arg model "$OLLAMA_MODEL" \
            --rawfile prompt /tmp/prompt.txt \
            '{
              model: $model,
              messages: [
                { role: "system", content: "Self-resolving code review agent. Be practical - acknowledge intentional changes, fix real issues. JSON only." },
                { role: "user", content: $prompt }
              ],
              options: { temperature: 0.1, num_ctx: 131072, num_predict: 8192 },
              stream: false
            }' > /tmp/payload.json
          
          if curl -sf --max-time 300 \
            -H "Authorization: Bearer $OLLAMA_API_KEY" \
            -H "Content-Type: application/json" \
            -d @/tmp/payload.json \
            "$OLLAMA_HOST/api/chat" > /tmp/response.json; then
            jq -r '.message.content // empty' /tmp/response.json > /tmp/resolutions.json
          else
            echo '{"resolutions":[],"summary":"API error","all_resolved":false}' > /tmp/resolutions.json
          fi
          
          if ! jq empty /tmp/resolutions.json 2>/dev/null; then
            echo '{"resolutions":[],"summary":"Parse error","all_resolved":false}' > /tmp/resolutions.json
          fi
          
          FIX_COUNT=$(jq '[.resolutions[] | select(.category == "fix")] | length' /tmp/resolutions.json)
          ACK_COUNT=$(jq '[.resolutions[] | select(.category == "acknowledge")] | length' /tmp/resolutions.json)
          ALL_RESOLVED=$(jq -r '.all_resolved' /tmp/resolutions.json)
          
          echo "fix_count=$FIX_COUNT" >> $GITHUB_OUTPUT
          echo "ack_count=$ACK_COUNT" >> $GITHUB_OUTPUT
          echo "resolved=$ALL_RESOLVED" >> $GITHUB_OUTPUT

      - name: Apply fixes
        if: steps.resolve.outputs.fix_count != '0'
        run: |
          jq -c '.resolutions[] | select(.category == "fix")' /tmp/resolutions.json | while read -r fix; do
            FILE=$(echo "$fix" | jq -r '.file')
            OLD=$(echo "$fix" | jq -r '.old_content')
            NEW=$(echo "$fix" | jq -r '.new_content')
            
            [[ -z "$FILE" || "$FILE" == "null" ]] && continue
            [[ "$FILE" =~ \.\./|^/ ]] && continue
            [[ ! -f "$FILE" ]] && continue
            
            # Validate OLD is not empty (prevents file corruption)
            if [[ -z "$OLD" || "$OLD" == "null" ]]; then
              echo "‚ö†Ô∏è Skipping fix with empty old_content"
              continue
            fi
            
            if grep -qF "$OLD" "$FILE"; then
              # Use perl with environment variables to handle slashes in content
              OLD="$OLD" NEW="$NEW" perl -i -p0e 's/\Q$ENV{OLD}\E/$ENV{NEW}/s' "$FILE" && echo "‚úÖ Fixed: $FILE"
            fi
          done

      - name: Commit fixes
        if: steps.resolve.outputs.fix_count != '0'
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "fix: self-resolve review issues (Ollama)"
          branch: ${{ github.head_ref }}

      - name: Post resolution summary
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          RESOLVED: ${{ steps.resolve.outputs.resolved }}
          FIX_COUNT: ${{ steps.resolve.outputs.fix_count }}
          ACK_COUNT: ${{ steps.resolve.outputs.ack_count }}
        run: |
          SUMMARY=$(jq -r '.summary' /tmp/resolutions.json)
          
          BODY="## üîÑ Self-Resolution Complete

          $SUMMARY

          | Resolution | Count |
          |------------|-------|
          | Fixes Applied | $FIX_COUNT |
          | Acknowledged (Intentional) | $ACK_COUNT |

          <details>
          <summary>Details</summary>

          \`\`\`json
          $(cat /tmp/resolutions.json)
          \`\`\`
          </details>"
          
          gh pr comment "$PR_NUMBER" --body "$BODY"
          
          # If all resolved, dismiss ALL our blocking reviews
          if [[ "$RESOLVED" == "true" ]]; then
            echo "‚úÖ All issues resolved - dismissing all blocking reviews"
            # Find ALL our blocking reviews and dismiss them
            REVIEW_IDS=$(gh api "repos/${{ github.repository }}/pulls/$PR_NUMBER/reviews" \
              --jq '[.[] | select(.user.login == "github-actions[bot]" and .state == "CHANGES_REQUESTED")] | .[].id')
            
            if [[ -n "$REVIEW_IDS" ]]; then
              for REVIEW_ID in $REVIEW_IDS; do
                echo "Dismissing review ID: $REVIEW_ID"
                gh api -X PUT "repos/${{ github.repository }}/pulls/$PR_NUMBER/reviews/$REVIEW_ID/dismissals" \
                  -f message="All issues have been resolved or acknowledged as intentional changes." || echo "‚ö†Ô∏è Could not dismiss review $REVIEW_ID"
              done
            else
              echo "No blocking reviews found to dismiss"
            fi
          fi

  # ============================================
  # Copilot Autofix - Fetch and apply security suggestions
  # ============================================
  copilot-autofix:
    name: Apply Copilot Autofix
    needs: initial-review
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha }}
          token: ${{ secrets.CI_GITHUB_TOKEN || secrets.GITHUB_TOKEN }}

      - name: Checkout PR branch
        env:
          HEAD_REF: ${{ github.head_ref }}
        run: git checkout "$HEAD_REF"

      - name: Fetch code scanning alerts with autofix
        id: alerts
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Get all open code scanning alerts for this PR's ref
          ALERTS=$(gh api repos/${{ github.repository }}/code-scanning/alerts \
            --jq '[.[] | select(.state == "open") | {number: .number, rule: .rule.id, file: .most_recent_instance.location.path}]' 2>/dev/null || echo '[]')
          
          echo "Found $(echo "$ALERTS" | jq 'length') open alerts"
          
          # Check each alert for autofix availability
          AUTOFIXES='[]'
          for alert_num in $(echo "$ALERTS" | jq -r '.[].number'); do
            echo "Checking alert #$alert_num for autofix..."
            
            AUTOFIX=$(gh api repos/${{ github.repository }}/code-scanning/alerts/$alert_num/autofix 2>/dev/null || echo '{}')
            
            if echo "$AUTOFIX" | jq -e '.status == "succeeded"' > /dev/null 2>&1; then
              echo "‚úÖ Autofix available for alert #$alert_num"
              AUTOFIXES=$(echo "$AUTOFIXES" | jq --argjson fix "$AUTOFIX" --arg num "$alert_num" '. + [{alert: ($num | tonumber), fix: $fix}]')
            fi
          done
          
          echo "$AUTOFIXES" > /tmp/autofixes.json
          FIX_COUNT=$(echo "$AUTOFIXES" | jq 'length')
          echo "fix_count=$FIX_COUNT" >> $GITHUB_OUTPUT
          echo "üìä Found $FIX_COUNT autofixes to evaluate"

      - name: Evaluate and apply autofixes
        if: steps.alerts.outputs.fix_count != '0'
        id: apply
        env:
          OLLAMA_API_KEY: ${{ secrets.OLLAMA_API_KEY }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          HEAD_REF: ${{ github.head_ref }}
        run: |
          # Use Ollama to evaluate each autofix suggestion
          cat > /tmp/prompt.txt << 'EOF'
          You are evaluating Copilot Autofix suggestions for code scanning alerts.
          For each autofix, determine if it should be applied:
          
          1. Is the fix safe and correct?
          2. Does it properly address the security issue?
          3. Will it break existing functionality?
          
          Respond with JSON:
          {
            "decisions": [
              {
                "alert": <number>,
                "apply": true/false,
                "reason": "why approve or reject"
              }
            ]
          }
          
          AUTOFIX SUGGESTIONS:
          EOF
          
          cat /tmp/autofixes.json >> /tmp/prompt.txt
          
          jq -n \
            --arg model "$OLLAMA_MODEL" \
            --rawfile prompt /tmp/prompt.txt \
            '{
              model: $model,
              messages: [
                { role: "system", content: "Security fix evaluator. Be conservative - only approve clearly safe fixes." },
                { role: "user", content: $prompt }
              ],
              options: { temperature: 0.1, num_ctx: 32768 },
              stream: false
            }' > /tmp/payload.json
          
          if curl -sf --max-time 120 \
            -H "Authorization: Bearer $OLLAMA_API_KEY" \
            -H "Content-Type: application/json" \
            -d @/tmp/payload.json \
            "$OLLAMA_HOST/api/chat" > /tmp/response.json; then
            jq -r '.message.content // empty' /tmp/response.json > /tmp/decisions.json
          else
            echo '{"decisions":[]}' > /tmp/decisions.json
          fi
          
          if ! jq empty /tmp/decisions.json 2>/dev/null; then
            echo '{"decisions":[]}' > /tmp/decisions.json
          fi
          
          # Apply approved autofixes via GitHub API
          APPLIED=0
          for row in $(jq -c '.decisions[] | select(.apply == true)' /tmp/decisions.json); do
            ALERT_NUM=$(echo "$row" | jq -r '.alert')
            echo "Applying autofix for alert #$ALERT_NUM..."
            
            # Use the autofix commit endpoint
            if gh api repos/${{ github.repository }}/code-scanning/alerts/$ALERT_NUM/autofix \
              -X POST \
              -f ref="refs/heads/$HEAD_REF" \
              -f message="fix: apply Copilot autofix for alert #$ALERT_NUM" 2>/dev/null; then
              echo "‚úÖ Applied autofix for alert #$ALERT_NUM"
              APPLIED=$((APPLIED + 1))
            else
              echo "‚ö†Ô∏è Could not apply autofix for alert #$ALERT_NUM"
            fi
          done
          
          echo "applied_count=$APPLIED" >> $GITHUB_OUTPUT

      - name: Post autofix summary
        if: steps.alerts.outputs.fix_count != '0'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          FIX_COUNT=${{ steps.alerts.outputs.fix_count }}
          APPLIED=${{ steps.apply.outputs.applied_count || '0' }}
          
          BODY="## üîß Copilot Autofix Evaluation

          | Metric | Count |
          |--------|-------|
          | Autofixes Available | $FIX_COUNT |
          | Autofixes Applied | $APPLIED |

          <details>
          <summary>Evaluation Details</summary>

          \`\`\`json
          $(cat /tmp/decisions.json 2>/dev/null || echo '{}')
          \`\`\`
          </details>"
          
          gh pr comment ${{ github.event.pull_request.number }} --body "$BODY"

  # ============================================
  # Monitor AI Feedback - Triggered on any comment/review
  # ============================================
  monitor-ai-feedback:
    name: Monitor & Resolve AI Feedback
    # Triggers on any AI bot feedback INCLUDING our own (github-actions[bot])
    # Loop prevention is handled in the "Collect all AI feedback" step by filtering out resolution summaries
    if: |
      (github.event_name == 'pull_request_review' && 
       contains(fromJSON('["github-actions[bot]","gemini-code-assist[bot]","copilot[bot]","amazon-q-developer[bot]","coderabbitai[bot]","cursor[bot]","github-advanced-security[bot]"]'), github.actor)) ||
      (github.event_name == 'pull_request_review_comment' &&
       contains(fromJSON('["github-actions[bot]","gemini-code-assist[bot]","copilot[bot]","amazon-q-developer[bot]","coderabbitai[bot]","cursor[bot]","github-advanced-security[bot]"]'), github.event.comment.user.login)) ||
      (github.event_name == 'issue_comment' && 
       github.event.issue.pull_request &&
       contains(fromJSON('["github-actions[bot]","gemini-code-assist[bot]","copilot[bot]","amazon-q-developer[bot]","coderabbitai[bot]","cursor[bot]","github-advanced-security[bot]"]'), github.event.comment.user.login))
    runs-on: ubuntu-latest
    
    steps:
      - name: Check required secrets
        env:
          OLLAMA_API_KEY: ${{ secrets.OLLAMA_API_KEY }}
        run: |
          if [[ -z "$OLLAMA_API_KEY" ]]; then
            echo "::error::OLLAMA_API_KEY secret is not configured"
            exit 1
          fi

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          # Use CI_GITHUB_TOKEN to allow commits to trigger workflows
          token: ${{ secrets.CI_GITHUB_TOKEN || secrets.GITHUB_TOKEN }}

      - name: Get PR number
        id: pr
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          EVENT_NAME: ${{ github.event_name }}
          PR_NUMBER_FROM_PR: ${{ github.event.pull_request.number }}
          PR_NUMBER_FROM_ISSUE: ${{ github.event.issue.number }}
        run: |
          # Determine PR number based on event type
          if [[ "$EVENT_NAME" == "pull_request_review" ]] || [[ "$EVENT_NAME" == "pull_request_review_comment" ]]; then
            PR_NUM="$PR_NUMBER_FROM_PR"
          else
            PR_NUM="$PR_NUMBER_FROM_ISSUE"
          fi
          echo "number=$PR_NUM" >> $GITHUB_OUTPUT
          
          # Get PR head ref for checkout
          HEAD_REF=$(gh pr view "$PR_NUM" --json headRefName -q '.headRefName')
          echo "head_ref=$HEAD_REF" >> $GITHUB_OUTPUT

      - name: Checkout PR branch
        env:
          HEAD_REF: ${{ steps.pr.outputs.head_ref }}
        run: git checkout "$HEAD_REF"

      - name: Collect all AI feedback
        id: feedback
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_NUM=${{ steps.pr.outputs.number }}
          
          # Loop prevention: Filter out our own resolution summaries and previous Ollama reviews
          # We only want to process NEW feedback that hasn't been addressed yet
          
          # Get all unresolved review comments from AI agents
          gh api repos/${{ github.repository }}/pulls/$PR_NUM/comments \
            --jq '[.[] | select(.user.login | endswith("[bot]")) | {id: .id, user: .user.login, body: .body, path: .path, line: .line}]' > /tmp/review_comments.json || echo '[]' > /tmp/review_comments.json
          
          # Get all issue comments from AI agents, excluding our resolution summaries
          gh api repos/${{ github.repository }}/issues/$PR_NUM/comments \
            --jq '[.[] | select(
              (.user.login | endswith("[bot]")) and
              (.body | contains("## üîÑ AI Feedback Resolution") | not) and
              (.body | contains("## ‚úÖ All Checks Passed") | not)
            ) | {id: .id, user: .user.login, body: .body}]' > /tmp/issue_comments.json || echo '[]' > /tmp/issue_comments.json
          
          # Get reviews from AI agents (non-approved, with actual issues to address)
          # For Ollama reviews: only process if they have actionable issues (not just summaries)
          gh api repos/${{ github.repository }}/pulls/$PR_NUM/reviews \
            --jq '[.[] | select(
              (.user.login | endswith("[bot]")) and 
              .state != "APPROVED" and
              (.body | contains("\"issues\":[]") | not)
            ) | {id: .id, user: .user.login, body: .body, state: .state}]' > /tmp/reviews.json || echo '[]' > /tmp/reviews.json
          
          # Combine all feedback (handle empty arrays properly)
          jq -s 'map(select(. != null)) | add // []' /tmp/review_comments.json /tmp/issue_comments.json /tmp/reviews.json > /tmp/all_feedback.json
          
          # Additional loop prevention: Check if we've already posted too many resolution comments
          ALREADY_PROCESSED=$(gh api repos/${{ github.repository }}/issues/$PR_NUM/comments \
            --jq "[.[] | select(.user.login == \"github-actions[bot]\" and (.body | contains(\"AI Feedback Resolution\"))) | .body] | length")
          
          if [[ "$ALREADY_PROCESSED" -gt 3 ]]; then
            echo "‚ö†Ô∏è Detected potential loop - too many resolution comments. Stopping."
            echo "count=0" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          FEEDBACK_COUNT=$(jq 'length' /tmp/all_feedback.json)
          echo "count=$FEEDBACK_COUNT" >> $GITHUB_OUTPUT
          echo "üìä Found $FEEDBACK_COUNT feedback items to process"

      - name: Analyze and generate fixes
        if: steps.feedback.outputs.count != '0'
        id: analyze
        env:
          OLLAMA_API_KEY: ${{ secrets.OLLAMA_API_KEY }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Get current code state
          gh pr diff ${{ steps.pr.outputs.number }} --color=never > /tmp/diff.txt
          
          cat > /tmp/prompt.txt << 'EOF'
          You are a code improvement agent. Analyze this AI reviewer feedback and generate fixes.
          
          For each piece of feedback:
          1. Determine if it's actionable (needs a code change) or informational
          2. If actionable, generate a fix with exact old_content and new_content
          3. Categorize: critical (security/bug), high (functionality), medium (quality), low (style)
          4. Determine if the fix is safe to auto-apply
          
          Respond with JSON:
          {
            "fixes": [
              {
                "feedback_id": "id of the comment",
                "feedback_user": "bot name",
                "category": "critical|high|medium|low|informational",
                "action": "fix|acknowledge|dismiss",
                "reason": "why this action",
                "file": "path if fix needed",
                "old_content": "exact text to find",
                "new_content": "replacement text",
                "safe_to_apply": true/false
              }
            ],
            "summary": "overall summary of actions taken"
          }
          
          AI FEEDBACK:
          EOF
          
          cat /tmp/all_feedback.json >> /tmp/prompt.txt
          echo -e "\n\nCURRENT DIFF:\n" >> /tmp/prompt.txt
          head -c 50000 /tmp/diff.txt >> /tmp/prompt.txt
          
          jq -n \
            --arg model "$OLLAMA_MODEL" \
            --rawfile prompt /tmp/prompt.txt \
            '{
              model: $model,
              messages: [
                { role: "system", content: "Code improvement agent. Generate precise fixes for AI feedback. JSON only." },
                { role: "user", content: $prompt }
              ],
              options: { temperature: 0.1, num_ctx: 131072, num_predict: 8192 },
              stream: false
            }' > /tmp/payload.json
          
          if curl -sf --max-time 300 \
            -H "Authorization: Bearer $OLLAMA_API_KEY" \
            -H "Content-Type: application/json" \
            -d @/tmp/payload.json \
            "$OLLAMA_HOST/api/chat" > /tmp/response.json; then
            jq -r '.message.content // empty' /tmp/response.json > /tmp/fixes.json
          else
            echo '{"fixes":[],"summary":"API error"}' > /tmp/fixes.json
          fi
          
          if ! jq empty /tmp/fixes.json 2>/dev/null; then
            echo '{"fixes":[],"summary":"Parse error"}' > /tmp/fixes.json
          fi
          
          FIX_COUNT=$(jq '[.fixes[] | select(.action == "fix")] | length' /tmp/fixes.json)
          echo "fix_count=$FIX_COUNT" >> $GITHUB_OUTPUT

      - name: Apply fixes
        if: steps.analyze.outputs.fix_count != '0'
        run: |
          jq -c '.fixes[] | select(.action == "fix" and .safe_to_apply == true)' /tmp/fixes.json | while read -r fix; do
            FILE=$(echo "$fix" | jq -r '.file')
            OLD=$(echo "$fix" | jq -r '.old_content')
            NEW=$(echo "$fix" | jq -r '.new_content')
            
            [[ "$FILE" =~ \.\./|^/ ]] && continue
            [[ ! -f "$FILE" ]] && continue
            
            # Validate OLD is not empty (prevents file corruption)
            if [[ -z "$OLD" || "$OLD" == "null" ]]; then
              echo "‚ö†Ô∏è Skipping fix with empty old_content"
              continue
            fi
            
            if grep -qF "$OLD" "$FILE"; then
              # Use perl with environment variables to handle slashes in content
              OLD="$OLD" NEW="$NEW" perl -i -p0e 's/\Q$ENV{OLD}\E/$ENV{NEW}/s' "$FILE" && echo "‚úÖ Applied fix to $FILE"
            fi
          done

      - name: Commit fixes
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "fix: resolve AI feedback (automated)"
          branch: ${{ steps.pr.outputs.head_ref }}

      - name: Post resolution summary
        if: steps.feedback.outputs.count != '0' && steps.analyze.outputs.fix_count != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          SUMMARY=$(jq -r '.summary' /tmp/fixes.json)
          FIX_COUNT=$(jq '[.fixes[] | select(.action == "fix")] | length' /tmp/fixes.json)
          ACK_COUNT=$(jq '[.fixes[] | select(.action == "acknowledge")] | length' /tmp/fixes.json)
          
          BODY="## üîÑ AI Feedback Resolution

          $SUMMARY

          | Action | Count |
          |--------|-------|
          | Fixes Applied | $FIX_COUNT |
          | Acknowledged | $ACK_COUNT |

          <details>
          <summary>Details</summary>

          \`\`\`json
          $(cat /tmp/fixes.json)
          \`\`\`
          </details>"
          
          gh pr comment ${{ steps.pr.outputs.number }} --body "$BODY"

  # ============================================
  # Check if Ready to Merge
  # ============================================
  check-ready:
    name: Check Merge Readiness
    if: github.event_name == 'check_suite' && github.event.check_suite.conclusion == 'success'
    runs-on: ubuntu-latest
    
    steps:
      - name: Get associated PRs
        id: prs
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Get PRs associated with this check suite
          gh api repos/${{ github.repository }}/commits/${{ github.event.check_suite.head_sha }}/pulls \
            --jq '.[0].number // empty' > /tmp/pr_num.txt
          
          PR_NUM=$(cat /tmp/pr_num.txt)
          if [[ -z "$PR_NUM" ]]; then
            echo "No PR found"
            exit 0
          fi
          echo "number=$PR_NUM" >> $GITHUB_OUTPUT

      - name: Check all conditions
        if: steps.prs.outputs.number != ''
        id: check
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_NUM=${{ steps.prs.outputs.number }}
          
          # Check CI status
          CI_STATUS=$(gh pr checks "$PR_NUM" --json state -q '[.[] | select(.state != "SUCCESS" and .state != "SKIPPED")] | length')
          
          # Check for blocking reviews
          BLOCKING=$(gh api repos/${{ github.repository }}/pulls/$PR_NUM/reviews \
            --jq '[.[] | select(.state == "CHANGES_REQUESTED")] | length')
          
          # Check for unresolved threads
          # shellcheck disable=SC2016
          GRAPHQL_QUERY='query($owner: String!, $repo: String!, $pr: Int!) { repository(owner: $owner, name: $repo) { pullRequest(number: $pr) { reviewThreads(first: 100) { nodes { isResolved } } } } }'
          UNRESOLVED=$(gh api graphql -f query="$GRAPHQL_QUERY" \
            -f owner="${{ github.repository_owner }}" \
            -f repo="${{ github.event.repository.name }}" \
            -F pr="$PR_NUM" \
            --jq '[.data.repository.pullRequest.reviewThreads.nodes[] | select(.isResolved == false)] | length')
          
          # Check draft status
          IS_DRAFT=$(gh pr view "$PR_NUM" --json isDraft -q '.isDraft')
          
          echo "ci_failures=$CI_STATUS" >> $GITHUB_OUTPUT
          echo "blocking_reviews=$BLOCKING" >> $GITHUB_OUTPUT
          echo "unresolved_threads=$UNRESOLVED" >> $GITHUB_OUTPUT
          echo "is_draft=$IS_DRAFT" >> $GITHUB_OUTPUT
          
          if [[ "$CI_STATUS" == "0" && "$BLOCKING" == "0" && "$UNRESOLVED" == "0" ]]; then
            echo "ready=true" >> $GITHUB_OUTPUT
          else
            echo "ready=false" >> $GITHUB_OUTPUT
          fi

      - name: Mark ready for review
        if: steps.check.outputs.ready == 'true' && steps.check.outputs.is_draft == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh pr ready ${{ steps.prs.outputs.number }}
          echo "‚úÖ Marked PR as ready for review"

      - name: Auto-merge
        if: steps.check.outputs.ready == 'true' && steps.check.outputs.is_draft == 'false'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_NUM=${{ steps.prs.outputs.number }}
          
          # Final approval comment
          gh pr comment "$PR_NUM" --body "## ‚úÖ All Checks Passed

          - CI: ‚úÖ All green
          - Reviews: ‚úÖ No blocking reviews  
          - Threads: ‚úÖ All resolved

          **Auto-merging now.**"
          
          # Merge
          gh pr merge "$PR_NUM" --squash --delete-branch || echo "Merge failed - may need manual intervention"
