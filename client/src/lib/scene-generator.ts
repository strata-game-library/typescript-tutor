// Scene Generator for Pygame Components
// Combines selected components into a complete pygame game script

import type { ComponentType } from './pygame-component-types';
// Import necessary types and functions
import { getComponentById } from './pygame-components';

// Define ComponentSelection interface locally
export interface ComponentSelection {
  componentId: string;
  variant: string;
  assets: Record<string, string>;
  parameters: Record<string, any>;
}

export interface SceneConfig {
  name: string;
  width: number;
  height: number;
  fps: number;
  backgroundColor: string;
}

export interface GeneratorOptions {
  sceneConfig: SceneConfig;
  selectedComponents: ComponentSelection[];
  assetMapping?: Record<string, string>;
}

// Template parameter replacer
function replaceTemplateParams(
  code: string,
  params: Record<string, any>,
  assets: Record<string, string> = {}
): string {
  let result = code;

  // Replace parameters
  Object.entries(params).forEach(([key, value]) => {
    const regex = new RegExp(`{{${key}}}`, 'g');
    result = result.replace(regex, String(value));
  });

  // Replace asset references
  Object.entries(assets).forEach(([key, path]) => {
    const regex = new RegExp(`{{${key}}}`, 'g');
    result = result.replace(regex, `"${path}"`);
  });

  return result;
}

// Helper function to determine component category
function determineComponentCategory(type: ComponentType): string {
  const categoryMap: Record<ComponentType, string> = {
    sprite: 'movement',
    platform: 'world',
    ball: 'movement',
    paddle: 'movement',
    enemy: 'combat',
    collectible: 'world',
    background: 'world',
    scoreText: 'ui',
    button: 'ui',
    particleEffect: 'ui',
    timer: 'ui',
    healthBar: 'ui',
  };
  return categoryMap[type] || 'world';
}

// Main scene generator function
export function generatePygameScene(options: GeneratorOptions): string {
  const { sceneConfig, selectedComponents } = options;

  // Group components by type for organized code generation
  const componentSystems: Record<string, string[]> = {
    movement: [],
    combat: [],
    ui: [],
    world: [],
  };

  // Process each selected component
  selectedComponents.forEach((selection) => {
    const component = getComponentById(selection.componentId);
    if (!component) return;

    // Generate code using the component's generateCode method
    const componentCode = component.generateCode({
      ...component.defaultProperties,
      ...selection.parameters,
    });

    // Determine category based on component type
    const category = determineComponentCategory(component.type);

    // Add the generated code to the appropriate system
    componentSystems[category].push(componentCode);
  });

  // Generate the complete pygame script
  return `#!/usr/bin/env python3
"""
${sceneConfig.name}
Generated by Pygame Component System
"""

import pygame
import sys
import math
import random
import json
import time

# Initialize Pygame
pygame.init()
pygame.mixer.init()
pygame.font.init()

# Game Configuration
SCREEN_WIDTH = ${sceneConfig.width}
SCREEN_HEIGHT = ${sceneConfig.height}
FPS = ${sceneConfig.fps}
BACKGROUND_COLOR = pygame.Color("${sceneConfig.backgroundColor}")

# Create game window
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption("${sceneConfig.name}")
clock = pygame.time.Clock()

# Player class with all required attributes
class Player:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.width = 40
        self.height = 40
        self.velocity_x = 0
        self.velocity_y = 0
        self.on_ground = False
        self.facing_right = True
        self.rect = pygame.Rect(x, y, self.width, self.height)
        self.health = 100
        self.max_health = 100
        self.mass = 1.0
        self.elasticity = 0.8
        
    def update(self):
        self.rect.x = int(self.x)
        self.rect.y = int(self.y)
        
    def draw(self, screen):
        color = (0, 100, 255)
        pygame.draw.rect(screen, color, self.rect)
        # Draw facing direction indicator
        if self.facing_right:
            pygame.draw.rect(screen, (255, 255, 255), 
                           (int(self.x + self.width - 10), int(self.y + 10), 5, 20))
        else:
            pygame.draw.rect(screen, (255, 255, 255),
                           (int(self.x + 5), int(self.y + 10), 5, 20))
    
    def play_sound(self, sound_path):
        # Placeholder for sound playing
        # In real implementation, would load and play the sound
        pass
        
    def take_damage(self, amount):
        self.health = max(0, self.health - amount)
        return self.health > 0

# Enemy base class
class Enemy:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.width = 30
        self.height = 30
        self.velocity_x = 0
        self.velocity_y = 0
        self.rect = pygame.Rect(x, y, self.width, self.height)
        self.health = 50
        self.mass = 0.8
        self.elasticity = 0.5
        
    def take_damage(self, amount):
        self.health -= amount
        
    def stun(self, duration):
        # Placeholder for stun effect
        pass
        
    def update(self):
        self.rect.x = int(self.x)
        self.rect.y = int(self.y)
        
    def draw(self, screen):
        color = (200, 50, 50)
        pygame.draw.rect(screen, color, self.rect)

# Platform class
class Platform:
    def __init__(self, x, y, width, height):
        self.x = x
        self.y = y
        self.width = width
        self.height = height
        self.rect = pygame.Rect(x, y, width, height)
        
    def draw(self, screen):
        pygame.draw.rect(screen, (100, 100, 100), self.rect)

# Initialize game objects
player = Player(100, 300)
enemies = []
platforms = [
    Platform(0, 550, 800, 50),  # Ground
    Platform(200, 450, 150, 20),  # Platform 1
    Platform(450, 350, 150, 20),  # Platform 2
    Platform(300, 250, 100, 20),  # Platform 3
]

# Component Systems
${componentSystems.movement.length > 0 ? '# Movement Systems\n' + componentSystems.movement.join('\n') : ''}
${componentSystems.combat.length > 0 ? '\n# Combat Systems\n' + componentSystems.combat.join('\n') : ''}
${componentSystems.ui.length > 0 ? '\n# UI Systems\n' + componentSystems.ui.join('\n') : ''}
${componentSystems.world.length > 0 ? '\n# World Systems\n' + componentSystems.world.join('\n') : ''}

# Initialize component systems
${selectedComponents
  .map((sel) => {
    const component = getComponentById(sel.componentId);
    if (!component) return '';

    // Generate initialization code based on component type
    switch (component.id) {
      case 'jump':
        return 'jump_system = JumpSystem(player)';
      case 'walk':
        return 'walk_system = WalkSystem(player)';
      case 'shooting':
        return 'shooting_system = ShootingSystem(player)';
      case 'melee':
        return 'melee_system = MeleeSystem(player)';
      case 'health':
        return 'health_system = HealthSystem(player)';
      case 'score':
        return 'score_system = ScoreSystem()';
      case 'gravity':
        return 'gravity_system = GravitySystem()\ngravity_system.add_entity(player)';
      case 'collision':
        // Check variant to use correct method name
        if (sel.variant === 'B') {
          return 'collision_system = CollisionSystem()\nfor platform in platforms:\n    collision_system.add_static_object(platform)';
        } else {
          return 'collision_system = CollisionSystem()\nfor platform in platforms:\n    collision_system.add_solid(platform)';
        }
      default:
        return '';
    }
  })
  .filter((line) => line)
  .join('\n')}

# Main game loop
running = True
dt = 0

while running:
    # Calculate delta time
    dt = clock.tick(FPS) / 1000.0
    
    # Handle events
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_ESCAPE:
                running = False
    
    # Get input states
    keys = pygame.key.get_pressed()
    mouse_pos = pygame.mouse.get_pos()
    
    # Update systems
${selectedComponents
  .map((sel) => {
    const component = getComponentById(sel.componentId);
    if (!component) return '';

    // Generate update code based on component type
    switch (component.id) {
      case 'jump':
        return '    jump_system.update(keys, dt)';
      case 'walk':
        return '    walk_system.update(keys, dt)';
      case 'shooting':
        return '    shooting_system.update(keys, mouse_pos, dt)';
      case 'melee':
        return '    melee_system.update(keys, enemies, dt)';
      case 'health':
        return '    health_system.update(dt)';
      case 'score':
        return '    score_system.update(dt)\n    score_system.collect_item(player.rect)';
      case 'gravity':
        return '    gravity_system.update(dt, platforms)';
      case 'collision':
        return '    collision_system.update()';
      default:
        return '';
    }
  })
  .filter((line) => line)
  .join('\n')}
    
    # Update player position
    if hasattr(player, 'velocity_x'):
        player.x += player.velocity_x * dt
    if hasattr(player, 'velocity_y'):
        player.y += player.velocity_y * dt
    player.update()
    
    # Update enemies
    for enemy in enemies:
        enemy.update()
    
    # Clear screen
    screen.fill(BACKGROUND_COLOR)
    
    # Draw platforms
    for platform in platforms:
        platform.draw(screen)
    
    # Draw player
    player.draw(screen)
    
    # Draw enemies
    for enemy in enemies:
        enemy.draw(screen)
    
    # Draw component visuals
${selectedComponents
  .map((sel) => {
    const component = getComponentById(sel.componentId);
    if (!component) return '';

    // Generate draw code for components with visual elements
    switch (component.id) {
      case 'shooting':
        return '    shooting_system.draw(screen)';
      case 'melee':
        return '    melee_system.draw(screen)';
      case 'health':
        return '    health_system.draw(screen)';
      case 'score':
        return '    score_system.draw(screen)';
      default:
        return '';
    }
  })
  .filter((line) => line)
  .join('\n')}
    
    # Update display
    pygame.display.flip()

# Cleanup
pygame.quit()
sys.exit()`;
}

// Helper function to generate a minimal test scene
export function generateTestScene(): string {
  const testConfig: GeneratorOptions = {
    sceneConfig: {
      name: 'Component Test Scene',
      width: 800,
      height: 600,
      fps: 60,
      backgroundColor: '#1a1a2e',
    },
    selectedComponents: [
      {
        componentId: 'walk',
        variant: 'A',
        assets: {},
        parameters: { max_speed: 200 },
      },
      {
        componentId: 'jump',
        variant: 'A',
        assets: {},
        parameters: { jump_power: 15 },
      },
      {
        componentId: 'gravity',
        variant: 'A',
        assets: {},
        parameters: {},
      },
      {
        componentId: 'collision',
        variant: 'A',
        assets: {},
        parameters: {},
      },
      {
        componentId: 'health',
        variant: 'A',
        assets: {},
        parameters: { max_health: 100 },
      },
      {
        componentId: 'score',
        variant: 'A',
        assets: {},
        parameters: {},
      },
    ],
  };

  return generatePygameScene(testConfig);
}
