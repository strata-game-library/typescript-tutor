{
  "nodes": {
    "start": {
      "id": "start",
      "speaker": "Pixel",
      "text": "Level 8 - CLASSES! Time to create blueprints for game objects! üèóÔ∏è",
      "followUp": "Classes are like character creators - design once, spawn infinite heroes, enemies, or items!",
      "options": [
        {
          "text": "Show me class power!",
          "next": "firstClass"
        },
        {
          "text": "What makes classes special?",
          "next": "whyClasses"
        }
      ]
    },
    "whyClasses": {
      "id": "whyClasses",
      "speaker": "Pixel",
      "text": "Classes bundle data AND behaviors together - like a character having health AND the ability to attack!",
      "followUp": "Without classes, you'd juggle separate lists for health, names, attacks... Classes keep it all together!",
      "options": [
        {
          "text": "That sounds organized! Show me!",
          "next": "firstClass"
        }
      ]
    },
    "firstClass": {
      "id": "firstClass",
      "speaker": "Pixel",
      "text": "A class is a blueprint. Objects are what you build from that blueprint!",
      "codeExample": "# Define a class (the blueprint)\nclass Player:\n    def __init__(self, name):\n        self.name = name\n        self.health = 100\n        self.level = 1\n    \n    def greet(self):\n        print(f'Hello, I am {self.name}!')\n\n# Create objects (instances)\nhero = Player('Hero')\nmage = Player('Mage')\n\n# Use the objects\nhero.greet()  # 'Hello, I am Hero!'\nprint(f'{mage.name} - Level {mage.level}')",
      "followUp": "__init__ is the constructor - it runs when you create a new object!",
      "options": [
        {
          "text": "What's 'self' all about?",
          "next": "selfExplained"
        },
        {
          "text": "Can I add more methods?",
          "next": "moreMethods"
        }
      ]
    },
    "selfExplained": {
      "id": "selfExplained",
      "speaker": "Pixel",
      "text": "'self' refers to the current object - like saying 'MY health' vs 'THE health'!",
      "codeExample": "class Enemy:\n    def __init__(self, name, health):\n        self.name = name      # THIS enemy's name\n        self.health = health  # THIS enemy's health\n    \n    def take_damage(self, amount):\n        self.health -= amount  # Reduce THIS enemy's health\n        print(f'{self.name} takes {amount} damage!')\n        print(f'{self.name} has {self.health} HP left')\n\n# Each enemy tracks its OWN health\ngoblin = Enemy('Goblin', 50)\norc = Enemy('Orc', 100)\n\ngoblin.take_damage(20)  # Only goblin is hurt\nprint(f'Orc still has {orc.health} HP')  # Orc is fine!",
      "followUp": "self keeps each object's data separate - crucial for multiple enemies!",
      "options": [
        {
          "text": "Show me more methods!",
          "next": "moreMethods"
        }
      ]
    },
    "moreMethods": {
      "id": "moreMethods",
      "speaker": "Pixel",
      "text": "Methods are functions that belong to the class - the actions objects can perform!",
      "codeExample": "class Character:\n    def __init__(self, name, hp, attack_power):\n        self.name = name\n        self.hp = hp\n        self.max_hp = hp\n        self.attack_power = attack_power\n        self.alive = True\n    \n    def attack(self, target):\n        if self.alive:\n            print(f'{self.name} attacks {target.name}!')\n            target.take_damage(self.attack_power)\n    \n    def take_damage(self, damage):\n        self.hp -= damage\n        if self.hp <= 0:\n            self.hp = 0\n            self.alive = False\n            print(f'{self.name} has been defeated!')\n    \n    def heal(self, amount):\n        if self.alive:\n            self.hp = min(self.hp + amount, self.max_hp)\n            print(f'{self.name} healed to {self.hp} HP!')\n\n# Battle!\nhero = Character('Hero', 100, 25)\nenemy = Character('Dragon', 200, 30)\n\nhero.attack(enemy)  # Hero attacks Dragon\nenemy.attack(hero)  # Dragon attacks Hero",
      "followUp": "Methods let objects interact with each other - the foundation of game mechanics!",
      "options": [
        {
          "text": "Can classes share attributes?",
          "next": "classVariables"
        },
        {
          "text": "What about inheritance?",
          "next": "inheritance"
        }
      ]
    },
    "classVariables": {
      "id": "classVariables",
      "speaker": "Pixel",
      "text": "Class variables are shared by ALL instances - like game-wide settings!",
      "codeExample": "class Enemy:\n    # Class variable - shared by all enemies\n    total_enemies = 0\n    difficulty_multiplier = 1.0\n    \n    def __init__(self, name, base_hp):\n        self.name = name\n        # Instance variable - unique to each enemy\n        self.hp = int(base_hp * Enemy.difficulty_multiplier)\n        Enemy.total_enemies += 1\n    \n    @classmethod\n    def set_difficulty(cls, multiplier):\n        cls.difficulty_multiplier = multiplier\n\n# Create enemies\nEnemy.set_difficulty(1.5)  # Hard mode!\ngoblin = Enemy('Goblin', 50)  # 75 HP\norc = Enemy('Orc', 100)  # 150 HP\n\nprint(f'Total enemies: {Enemy.total_enemies}')",
      "followUp": "Class variables affect ALL objects - perfect for global game settings!",
      "options": [
        {
          "text": "Tell me about inheritance!",
          "next": "inheritance"
        }
      ]
    },
    "inheritance": {
      "id": "inheritance",
      "speaker": "Pixel",
      "text": "Inheritance lets classes build on other classes - like enemy types sharing base behaviors!",
      "codeExample": "# Base class\nclass GameObject:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def move(self, dx, dy):\n        self.x += dx\n        self.y += dy\n\n# Child classes inherit from GameObject\nclass Player(GameObject):\n    def __init__(self, x, y, name):\n        super().__init__(x, y)  # Call parent constructor\n        self.name = name\n        self.health = 100\n    \n    def attack(self):\n        print(f'{self.name} swings sword!')\n\nclass Enemy(GameObject):\n    def __init__(self, x, y, enemy_type):\n        super().__init__(x, y)\n        self.type = enemy_type\n        self.health = 50\n    \n    def patrol(self):\n        print(f'{self.type} is patrolling...')\n\n# Both can move (inherited), but have unique abilities\nhero = Player(0, 0, 'Hero')\ngoblin = Enemy(10, 10, 'Goblin')\n\nhero.move(5, 0)     # Inherited method\nhero.attack()       # Player-specific\ngoblin.patrol()     # Enemy-specific",
      "followUp": "Inheritance = 'is a' relationship. Player IS A GameObject, so it inherits movement!",
      "options": [
        {
          "text": "Can I override inherited methods?",
          "next": "override"
        },
        {
          "text": "Show me a complete game example!",
          "next": "gameExample"
        }
      ]
    },
    "override": {
      "id": "override",
      "speaker": "Pixel",
      "text": "Yes! Child classes can override parent methods for specialized behavior!",
      "codeExample": "class Character:\n    def __init__(self, name):\n        self.name = name\n    \n    def speak(self):\n        print(f'{self.name} says: Hello!')\n\nclass Hero(Character):\n    def speak(self):  # Override parent method\n        print(f'{self.name} says: I will save the day!')\n\nclass Villain(Character):\n    def speak(self):  # Different override\n        print(f'{self.name} says: You cannot stop me!')\n\n# Each speaks differently\ngeneric = Character('NPC')\nhero = Hero('Brave Knight')\nvillain = Villain('Dark Lord')\n\ngeneric.speak()  # 'Hello!'\nhero.speak()     # 'I will save the day!'\nvillain.speak()  # 'You cannot stop me!'",
      "followUp": "Overriding lets each class customize inherited behaviors!",
      "options": [
        {
          "text": "Show me a full game system!",
          "next": "gameExample"
        }
      ]
    },
    "gameExample": {
      "id": "gameExample",
      "speaker": "Pixel",
      "text": "Let's build a complete RPG battle system with classes!",
      "codeExample": "import random\n\nclass Character:\n    def __init__(self, name, hp, attack, defense):\n        self.name = name\n        self.hp = hp\n        self.max_hp = hp\n        self.attack = attack\n        self.defense = defense\n        self.level = 1\n    \n    def take_damage(self, damage):\n        actual_damage = max(1, damage - self.defense)\n        self.hp -= actual_damage\n        return actual_damage\n    \n    def is_alive(self):\n        return self.hp > 0\n\nclass Hero(Character):\n    def __init__(self, name):\n        super().__init__(name, hp=100, attack=20, defense=5)\n        self.potions = 3\n        self.exp = 0\n    \n    def special_attack(self, target):\n        damage = self.attack * 2\n        dealt = target.take_damage(damage)\n        print(f'{self.name} uses Power Strike for {dealt} damage!')\n    \n    def use_potion(self):\n        if self.potions > 0:\n            heal = 50\n            self.hp = min(self.hp + heal, self.max_hp)\n            self.potions -= 1\n            print(f'{self.name} drinks potion! HP: {self.hp}/{self.max_hp}')\n\nclass Monster(Character):\n    def __init__(self, name, monster_type):\n        stats = {\n            'goblin': {'hp': 30, 'attack': 10, 'defense': 2},\n            'orc': {'hp': 50, 'attack': 15, 'defense': 5},\n            'dragon': {'hp': 200, 'attack': 40, 'defense': 10}\n        }\n        s = stats[monster_type]\n        super().__init__(name, s['hp'], s['attack'], s['defense'])\n        self.type = monster_type\n        self.gold_drop = s['hp'] // 10\n\n# Create characters\nhero = Hero('Brave Knight')\nmonster = Monster('Grunk', 'orc')\n\nprint(f'{hero.name} faces {monster.name} the {monster.type}!')\nhero.special_attack(monster)\nif monster.is_alive():\n    damage = hero.take_damage(monster.attack)\n    print(f'{monster.name} strikes back for {damage} damage!')",
      "followUp": "Classes make complex game systems manageable and expandable!",
      "options": [
        {
          "text": "Classes are powerful!",
          "next": "practiceChallenge"
        }
      ]
    },
    "practiceChallenge": {
      "id": "practiceChallenge",
      "speaker": "Pixel",
      "text": "Ultimate Challenge: Design a complete Item system with different item types!",
      "followUp": "Create base Item class, then Weapon, Armor, and Consumable subclasses!",
      "codeExample": "class Item:\n    def __init__(self, name, value):\n        self.name = name\n        self.value = value\n    \n    def use(self, character):\n        print(f'{character.name} uses {self.name}')\n\nclass Weapon(Item):\n    def __init__(self, name, value, damage):\n        super().__init__(name, value)\n        self.damage = damage\n    \n    def use(self, character):\n        character.attack += self.damage\n        print(f'{character.name} equips {self.name} (+{self.damage} attack)')\n\nclass Armor(Item):\n    def __init__(self, name, value, defense):\n        super().__init__(name, value)\n        self.defense = defense\n    \n    def use(self, character):\n        character.defense += self.defense\n        print(f'{character.name} wears {self.name} (+{self.defense} defense)')\n\nclass Consumable(Item):\n    def __init__(self, name, value, effect, amount):\n        super().__init__(name, value)\n        self.effect = effect\n        self.amount = amount\n    \n    def use(self, character):\n        if self.effect == 'heal':\n            character.hp += self.amount\n            print(f'{character.name} heals {self.amount} HP!')\n        elif self.effect == 'boost':\n            character.attack += self.amount\n            print(f'{character.name} gains {self.amount} attack!')\n\n# Test the system!\nclass Player:\n    def __init__(self, name):\n        self.name = name\n        self.hp = 100\n        self.attack = 10\n        self.defense = 5\n\nhero = Player('Hero')\nsword = Weapon('Fire Sword', 100, 15)\nshield = Armor('Iron Shield', 75, 10)\npotion = Consumable('Health Potion', 50, 'heal', 30)\n\nsword.use(hero)\nshield.use(hero)\npotion.use(hero)",
      "options": [
        {
          "text": "Object-oriented programming is amazing!",
          "next": "lessonComplete"
        }
      ]
    },
    "lessonComplete": {
      "id": "lessonComplete",
      "speaker": "Pixel",
      "text": "üéä LEVEL 8 COMPLETE! You've unlocked Object-Oriented Programming! üéØ",
      "followUp": "Classes let you build entire game worlds - characters, items, enemies, anything you can imagine!",
      "action": "completeLesson",
      "actionParams": { "lesson": 8, "nextLesson": 9 },
      "options": [
        {
          "text": "On to Lesson 9 - PyGame Introduction!",
          "action": "loadLesson",
          "actionParams": { "lesson": 9 }
        },
        {
          "text": "I want to start making games now!",
          "action": "startGameMode"
        },
        {
          "text": "Back to lesson menu",
          "action": "openLessons"
        }
      ]
    }
  },
  "startNode": "start"
}
