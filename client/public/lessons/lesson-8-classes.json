{
  "nodes": {
    "start": {
      "id": "start",
      "speaker": "Pixel",
      "text": "Level 8 - CLASSES! Time to create blueprints for game objects! üèóÔ∏è",
      "followUp": "Classes are like character creators - design once, spawn infinite heroes, enemies, or items in your Strata game!",
      "options": [
        {
          "text": "Show me class power!",
          "next": "firstClass"
        },
        {
          "text": "What makes classes special?",
          "next": "whyClasses"
        }
      ]
    },
    "whyClasses": {
      "id": "whyClasses",
      "speaker": "Pixel",
      "text": "Classes bundle data AND behaviors together - like a character having health AND the ability to attack!",
      "followUp": "Without classes, you'd juggle separate objects for health, names, attacks... Classes keep it all together!",
      "options": [
        {
          "text": "That sounds organized! Show me!",
          "next": "firstClass"
        }
      ]
    },
    "firstClass": {
      "id": "firstClass",
      "speaker": "Pixel",
      "text": "A class is a blueprint. Objects are what you build from that blueprint!",
      "codeExample": "// Define a class (the blueprint)\nclass Player {\n    name: string;\n    health: number;\n    level: number;\n\n    constructor(name) {\n        this.name = name;\n        this.health = 100;\n        this.level = 1;\n    }\n    \n    greet() {\n        console.log(`Hello, I am ${this.name}!`);\n    }\n}\n\n// Create objects (instances)\nlet hero = new Player('Hero');\nlet mage = new Player('Mage');\n\n// Use the objects\nhero.greet();  // 'Hello, I am Hero!'\nconsole.log(`${mage.name} - Level ${mage.level}`);",
      "followUp": "The constructor is a special function that runs when you create a new object with 'new'!",
      "options": [
        {
          "text": "What's 'this' all about?",
          "next": "thisExplained"
        },
        {
          "text": "Can I add more methods?",
          "next": "moreMethods"
        }
      ]
    },
    "thisExplained": {
      "id": "thisExplained",
      "speaker": "Pixel",
      "text": "'this' refers to the current object - like saying 'MY health' vs 'THE health'!",
      "codeExample": "class Enemy {\n    name: string;\n    health: number;\n\n    constructor(name, health) {\n        this.name = name;      // THIS enemy's name\n        this.health = health;  // THIS enemy's health\n    }\n    \n    takeDamage(amount) {\n        this.health -= amount;  // Reduce THIS enemy's health\n        console.log(`${this.name} takes ${amount} damage!`);\n        console.log(`${this.name} has ${this.health} HP left`);\n    }\n}\n\n// Each enemy tracks its OWN health\nlet goblin = new Enemy('Goblin', 50);\nlet orc = new Enemy('Orc', 100);\n\ngoblin.takeDamage(20);  // Only goblin is hurt\nconsole.log(`Orc still has ${orc.health} HP`);  // Orc is fine!",
      "followUp": "'this' keeps each object's data separate - crucial for multiple enemies!",
      "options": [
        {
          "text": "Show me more methods!",
          "next": "moreMethods"
        }
      ]
    },
    "moreMethods": {
      "id": "moreMethods",
      "speaker": "Pixel",
      "text": "Methods are functions that belong to the class - the actions objects can perform!",
      "codeExample": "class Character {\n    constructor(name, hp, attackPower) {\n        this.name = name;\n        this.hp = hp;\n        this.maxHp = hp;\n        this.attackPower = attackPower;\n        this.isAlive = true;\n    }\n    \n    attack(target) {\n        if (this.isAlive) {\n            console.log(`${this.name} attacks ${target.name}!`);\n            target.takeDamage(this.attackPower);\n        }\n    }\n    \n    takeDamage(damage) {\n        this.hp -= damage;\n        if (this.hp <= 0) {\n            this.hp = 0;\n            this.isAlive = false;\n            console.log(`${this.name} has been defeated!`);\n        }\n    }\n    \n    heal(amount) {\n        if (this.isAlive) {\n            this.hp = Math.min(this.hp + amount, this.maxHp);\n            console.log(`${this.name} healed to ${this.hp} HP!`);\n        }\n    }\n}\n\n// Battle!\nlet hero = new Character('Hero', 100, 25);\nlet dragon = new Character('Dragon', 200, 30);\n\nhero.attack(dragon);  // Hero attacks Dragon\ndragon.attack(hero);  // Dragon attacks Hero",
      "followUp": "Methods let objects interact with each other - the foundation of game mechanics!",
      "options": [
        {
          "text": "Tell me about inheritance!",
          "next": "inheritance"
        }
      ]
    },
    "inheritance": {
      "id": "inheritance",
      "speaker": "Pixel",
      "text": "Inheritance lets classes build on other classes - like different enemy types sharing base behaviors!",
      "codeExample": "// Base class\nclass GameObject {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    \n    move(dx, dy) {\n        this.x += dx;\n        this.y += dy;\n    }\n}\n\n// Child classes inherit from GameObject\nclass Player extends GameObject {\n    constructor(x, y, name) {\n        super(x, y);  // Call parent constructor\n        this.name = name;\n        this.health = 100;\n    }\n    \n    attack() {\n        console.log(`${this.name} swings sword!`);\n    }\n}\n\nclass Enemy extends GameObject {\n    constructor(x, y, type) {\n        super(x, y);\n        this.type = type;\n        this.health = 50;\n    }\n    \n    patrol() {\n        console.log(`${this.type} is patrolling...`);\n    }\n}\n\n// Both can move (inherited), but have unique abilities\nlet hero = new Player(0, 0, 'Hero');\nlet goblin = new Enemy(10, 10, 'Goblin');\n\nhero.move(5, 0);     // Inherited method\nhero.attack();       // Player-specific\ngoblin.patrol();     // Enemy-specific",
      "followUp": "Inheritance is an 'is-a' relationship. Player IS A GameObject, so it inherits movement!",
      "options": [
        {
          "text": "Can I override inherited methods?",
          "next": "override"
        },
        {
          "text": "Show me a complete game example!",
          "next": "gameExample"
        }
      ]
    },
    "override": {
      "id": "override",
      "speaker": "Pixel",
      "text": "Yes! Child classes can override parent methods for specialized behavior!",
      "codeExample": "class Character {\n    constructor(name) {\n        this.name = name;\n    }\n    \n    speak() {\n        console.log(`${this.name} says: Hello!`);\n    }\n}\n\nclass Hero extends Character {\n    speak() {  // Override parent method\n        console.log(`${this.name} says: I will save the day!`);\n    }\n}\n\nclass Villain extends Character {\n    speak() {  // Different override\n        console.log(`${this.name} says: You cannot stop me!`);\n    }\n}\n\n// Each speaks differently\nlet generic = new Character('NPC');\nlet hero = new Hero('Brave Knight');\nlet villain = new Villain('Dark Lord');\n\ngeneric.speak();  // 'Hello!'\nhero.speak();     // 'I will save the day!'\nvillain.speak();  // 'You cannot stop me!'",
      "followUp": "Overriding lets each class customize inherited behaviors!",
      "options": [
        {
          "text": "Show me a full game system!",
          "next": "gameExample"
        }
      ]
    },
    "gameExample": {
      "id": "gameExample",
      "speaker": "Pixel",
      "text": "Let's build a complete RPG battle system with classes!",
      "codeExample": "class Character {\n    constructor(name, hp, attack, defense) {\n        this.name = name;\n        this.hp = hp;\n        this.maxHp = hp;\n        this.attack = attack;\n        this.defense = defense;\n        this.level = 1;\n    }\n    \n    takeDamage(damage) {\n        let actualDamage = Math.max(1, damage - this.defense);\n        this.hp -= actualDamage;\n        return actualDamage;\n    }\n    \n    isAlive() {\n        return this.hp > 0;\n    }\n}\n\nclass Hero extends Character {\n    constructor(name) {\n        super(name, 100, 20, 5);\n        this.potions = 3;\n        this.exp = 0;\n    }\n    \n    specialAttack(target) {\n        let damage = this.attack * 2;\n        let dealt = target.takeDamage(damage);\n        console.log(`${this.name} uses Power Strike for ${dealt} damage!`);\n    }\n    \n    usePotion() {\n        if (this.potions > 0) {\n            let heal = 50;\n            this.hp = Math.min(this.hp + heal, this.maxHp);\n            this.potions--;\n            console.log(`${this.name} drinks potion! HP: ${this.hp}/${this.maxHp}`);\n        }\n    }\n}\n\n// Monster system\nclass Monster extends Character {\n    constructor(name, type) {\n        const stats = {\n            goblin: { hp: 30, attack: 10, defense: 2 },\n            orc: { hp: 50, attack: 15, defense: 5 }\n        };\n        const s = stats[type];\n        super(name, s.hp, s.attack, s.defense);\n        this.type = type;\n    }\n}\n\n// Create characters\nlet hero = new Hero('Brave Knight');\nlet monster = new Monster('Grunk', 'orc');\n\nconsole.log(`${hero.name} faces ${monster.name} the ${monster.type}!`);\nhero.specialAttack(monster);\nif (monster.isAlive()) {\n    let damage = hero.takeDamage(monster.attack);\n    console.log(`${monster.name} strikes back for ${damage} damage!`);\n}",
      "followUp": "Classes make complex game systems manageable and expandable!",
      "options": [
        {
          "text": "Classes are powerful!",
          "next": "practiceChallenge"
        }
      ]
    },
    "practiceChallenge": {
      "id": "practiceChallenge",
      "speaker": "Pixel",
      "text": "Ultimate Challenge: Design a complete Item system with different item types!",
      "followUp": "Create base Item class, then Weapon, Armor, and Consumable subclasses!",
      "codeExample": "class Item {\n    constructor(name, value) {\n        this.name = name;\n        this.value = value;\n    }\n    \n    use(character) {\n        console.log(`${character.name} uses ${this.name}`);\n    }\n}\n\nclass Weapon extends Item {\n    constructor(name, value, damage) {\n        super(name, value);\n        this.damage = damage;\n    }\n    \n    use(character) {\n        character.attack += this.damage;\n        console.log(`${character.name} equips ${this.name} (+${this.damage} attack)`);\n    }\n}\n\nclass Consumable extends Item {\n    constructor(name, value, healAmount) {\n        super(name, value);\n        this.healAmount = healAmount;\n    }\n    \n    use(character) {\n        character.hp += this.healAmount;\n        console.log(`${character.name} heals ${this.healAmount} HP!`);\n    }\n}\n\n// Test the system!\nlet hero = { name: 'Hero', hp: 50, attack: 10 };\nlet sword = new Weapon('Fire Sword', 100, 15);\nlet potion = new Consumable('Health Potion', 50, 30);\n\nsword.use(hero);\npotion.use(hero);",
      "options": [
        {
          "text": "Object-oriented programming is amazing!",
          "next": "lessonComplete"
        }
      ]
    },
    "lessonComplete": {
      "id": "lessonComplete",
      "speaker": "Pixel",
      "text": "üéä LEVEL 8 COMPLETE! You've unlocked Object-Oriented Programming! üéØ",
      "followUp": "Classes let you build entire game worlds - characters, items, enemies, anything you can imagine!",
      "action": "completeLesson",
      "actionParams": { "lesson": 8, "nextLesson": 9 },
      "options": [
        {
          "text": "On to Lesson 9 - Strata Introduction!",
          "action": "loadLesson",
          "actionParams": { "lesson": 9 }
        },
        {
          "text": "I want to start making games now!",
          "action": "startGameMode"
        },
        {
          "text": "Back to lesson menu",
          "action": "openLessons"
        }
      ]
    }
  },
  "startNode": "start"
}
