{
  "nodes": {
    "start": {
      "id": "start",
      "speaker": "Pixel",
      "text": "Level 6 - FUNCTIONS! Time to create your own commands! ðŸŽ¯",
      "followUp": "Functions are like creating your own power-ups - write once, use anywhere in your Strata game!",
      "options": [
        {
          "text": "Show me function power!",
          "next": "firstFunction"
        },
        {
          "text": "Why do I need functions?",
          "next": "whyFunctions"
        }
      ]
    },
    "whyFunctions": {
      "id": "whyFunctions",
      "speaker": "Pixel",
      "text": "Imagine coding 'enemy takes damage' 50 times... NO! Write it once as a function, call it 50 times!",
      "followUp": "Functions = no repeating yourself = happy programmer = better games!",
      "options": [
        {
          "text": "Sold! Teach me!",
          "next": "firstFunction"
        }
      ]
    },
    "firstFunction": {
      "id": "firstFunction",
      "speaker": "Pixel",
      "text": "Functions are defined with the 'function' keyword. Like creating a spell, then casting it!",
      "codeExample": "// Define the function (create the spell)\nfunction attack() {\n    console.log('Swinging sword!');\n    console.log('Enemy takes 10 damage!');\n}\n\n// Call the function (cast the spell)\nattack();\nattack(); // Can use it multiple times!",
      "followUp": "See? Define it once, then call it by name whenever you need!",
      "options": [
        {
          "text": "Can functions take inputs?",
          "next": "parameters"
        },
        {
          "text": "What about returning values?",
          "next": "returnValues"
        }
      ]
    },
    "parameters": {
      "id": "parameters",
      "speaker": "Pixel",
      "text": "Yes! Parameters let functions accept inputs - like damage amounts or enemy names!",
      "codeExample": "// Function with parameters\nfunction attack(enemyName, damage) {\n    console.log(`Attacking ${enemyName}!`);\n    console.log(`${enemyName} takes ${damage} damage!`);\n}\n\n// Call with different values\nattack('Goblin', 25);\nattack('Dragon', 50);\nattack('Slime', 10);",
      "followUp": "Parameters make functions flexible - one function, infinite possibilities!",
      "options": [
        {
          "text": "Can I have optional parameters?",
          "next": "defaultParams"
        },
        {
          "text": "How do I return values?",
          "next": "returnValues"
        }
      ]
    },
    "defaultParams": {
      "id": "defaultParams",
      "speaker": "Pixel",
      "text": "Default parameters give fallback values - perfect for optional settings!",
      "codeExample": "// Default parameters\nfunction heal(amount = 50, showEffect = true) {\n    console.log(`Healing ${amount} HP!`);\n    if (showEffect) {\n        console.log('âœ¨ Sparkles appear! âœ¨');\n    }\n}\n\n// Different ways to call\nheal();           // Uses defaults: 50, true\nheal(30);         // Custom amount: 30, true\nheal(100, false); // Full custom: 100, false",
      "followUp": "Defaults make functions user-friendly - they work even if you don't provide all the arguments!",
      "options": [
        {
          "text": "Show me return values!",
          "next": "returnValues"
        }
      ]
    },
    "returnValues": {
      "id": "returnValues",
      "speaker": "Pixel",
      "text": "Functions can return values - like asking 'how much damage?' and getting an answer!",
      "codeExample": "// Function that returns a value\nfunction calculateDamage(base, multiplier) {\n    let total = base * multiplier;\n    return total;\n}\n\n// Use the returned value\nlet damage = calculateDamage(10, 3);\nconsole.log(`Total damage: ${damage}`); // 30",
      "followUp": "Return sends values back to whoever called the function! It's like a result from a quest!",
      "options": [
        {
          "text": "Can functions call other functions?",
          "next": "functionCalls"
        },
        {
          "text": "Show me arrow functions!",
          "next": "arrowFunctions"
        }
      ]
    },
    "arrowFunctions": {
      "id": "arrowFunctions",
      "speaker": "Pixel",
      "text": "TypeScript has a shorter way to write functions called 'Arrow Functions'. They're super popular!",
      "codeExample": "// Regular function\nfunction double(x) {\n    return x * 2;\n}\n\n// Arrow function - a modern shortcut!\nconst doubleArrow = (x) => x * 2;\n\nconsole.log(doubleArrow(5)); // 10",
      "followUp": "They're great for quick, one-line operations and look really modern!",
      "options": [
        {
          "text": "Cool! Can functions call each other?",
          "next": "functionCalls"
        }
      ]
    },
    "functionCalls": {
      "id": "functionCalls",
      "speaker": "Pixel",
      "text": "Functions can call other functions - like combo attacks in fighting games!",
      "codeExample": "function rollDice() {\n    return Math.floor(Math.random() * 6) + 1;\n}\n\nfunction attackWithCritical() {\n    let baseDamage = 10;\n    let diceRoll = rollDice(); // Call another function!\n    \n    if (diceRoll === 6) {\n        console.log('CRITICAL HIT!');\n        return baseDamage * 3;\n    } else {\n        return baseDamage;\n    }\n}\n\n// Use it\nlet finalDamage = attackWithCritical();\nconsole.log(`Dealt ${finalDamage} damage!`);",
      "followUp": "Functions calling functions - that's how complex games are built!",
      "options": [
        {
          "text": "What about variable scope?",
          "next": "scope"
        }
      ]
    },
    "scope": {
      "id": "scope",
      "speaker": "Pixel",
      "text": "Variables inside functions are 'local' - they only exist inside that function's world!",
      "codeExample": "let playerGold = 100; // Global variable (visible everywhere)\n\nfunction buyItem(cost) {\n    let tax = cost * 0.1; // Local variable (only inside here)\n    let total = cost + tax;\n    \n    if (playerGold >= total) {\n        playerGold -= total;\n        return true;\n    }\n    return false;\n}\n\nif (buyItem(50)) {\n    console.log(`Purchase complete! Gold left: ${playerGold}`);\n} else {\n    console.log('Not enough gold!');\n}",
      "followUp": "Local variables are private to the function. Global variables are shared by everything!",
      "options": [
        {
          "text": "Show me a complete game system!",
          "next": "completeExample"
        }
      ]
    },
    "completeExample": {
      "id": "completeExample",
      "speaker": "Pixel",
      "text": "Let's build a complete combat system with functions!",
      "codeExample": "// Combat System\nfunction createCharacter(name, hp, attack) {\n    return { name, hp, attack };\n}\n\nfunction attackEnemy(attacker, defender) {\n    let damage = Math.floor(Math.random() * attacker.attack) + 1;\n    defender.hp -= damage;\n    console.log(`${attacker.name} deals ${damage} damage!`);\n    return damage;\n}\n\nconst isAlive = (char) => char.hp > 0;\n\nfunction battle(player, enemy) {\n    console.log(`Battle: ${player.name} vs ${enemy.name}!`);\n    \n    while (isAlive(player) && isAlive(enemy)) {\n        attackEnemy(player, enemy);\n        if (isAlive(enemy)) {\n            attackEnemy(enemy, player);\n        }\n        console.log(`HP - ${player.name}: ${player.hp}, ${enemy.name}: ${enemy.hp}`);\n    }\n    \n    let winner = isAlive(player) ? player : enemy;\n    console.log(`${winner.name} wins!`);\n}\n\n// Use the system\nlet hero = createCharacter('Hero', 100, 20);\nlet goblin = createCharacter('Goblin', 50, 15);\nbattle(hero, goblin);",
      "followUp": "See how functions work together to create a complete system? That's modular programming!",
      "options": [
        {
          "text": "Time for practice!",
          "next": "practiceChallenge"
        }
      ]
    },
    "practiceChallenge": {
      "id": "practiceChallenge",
      "speaker": "Pixel",
      "text": "Ultimate Challenge: Create a shop system with functions!",
      "followUp": "Make functions for: displaying items and buying items with gold!",
      "codeExample": "let playerGold = 100;\nlet inventory = [];\n\nfunction showShop(items) {\n    console.log('=== SHOP ===');\n    items.forEach((item, i) => {\n        console.log(`${i + 1}. ${item.name} - ${item.price}g`);\n    });\n}\n\nfunction buyItem(item) {\n    if (playerGold >= item.price) {\n        inventory.push(item.name);\n        playerGold -= item.price;\n        console.log('Bought ' + item.name);\n    } else {\n        console.log('Not enough gold!');\n    }\n}\n\nlet shopItems = [\n    { name: 'Sword', price: 50 },\n    { name: 'Potion', price: 20 }\n];\n\nshowShop(shopItems);\nbuyItem(shopItems[1]);\nconsole.log(`Gold: ${playerGold}, Inventory: ${inventory}`);",
      "options": [
        {
          "text": "Functions make everything easier!",
          "next": "lessonComplete"
        }
      ]
    },
    "lessonComplete": {
      "id": "lessonComplete",
      "speaker": "Pixel",
      "text": "ðŸŽŠ LEVEL 6 COMPLETE! You can now create your own commands! âš¡",
      "followUp": "Functions are the building blocks of every game - now you can build anything in Strata!",
      "action": "completeLesson",
      "actionParams": { "lesson": 6, "nextLesson": 7 },
      "options": [
        {
          "text": "On to Lesson 7 - Objects!",
          "action": "loadLesson",
          "actionParams": { "lesson": 7 }
        },
        {
          "text": "I want to build games now!",
          "action": "startGameMode"
        },
        {
          "text": "Back to lesson menu",
          "action": "openLessons"
        }
      ]
    }
  },
  "startNode": "start"
}
